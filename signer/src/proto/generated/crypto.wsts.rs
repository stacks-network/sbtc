// This file is @generated by prost-build.
/// <https://github.com/Trust-Machines/wsts/blob/91a37c8a097e6fa5d5a67519a72567bc82560c0d/src/traits.rs#L25-L42>
/// The saved state required to reconstruct a WSTS signer object. This is
/// the protobuf version of the state object. It is encrypted and stored in
/// the database.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignerState {
    /// The signer ID
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// The key IDs this signer controls
    #[prost(uint32, repeated, tag = "2")]
    pub key_ids: ::prost::alloc::vec::Vec<u32>,
    /// The total number of keys
    #[prost(uint32, tag = "3")]
    pub num_keys: u32,
    /// The total number of parties
    #[prost(uint32, tag = "4")]
    pub num_parties: u32,
    /// The threshold for signing
    #[prost(uint32, tag = "5")]
    pub threshold: u32,
    /// The aggregate group public key
    #[prost(message, optional, tag = "6")]
    pub group_key: ::core::option::Option<super::Point>,
    /// The party IDs and associated state for this signer
    #[prost(message, repeated, tag = "7")]
    pub parties: ::prost::alloc::vec::Vec<PartyState>,
}
/// The saved state required to reconstruct a party
/// <https://github.com/Trust-Machines/wsts/blob/91a37c8a097e6fa5d5a67519a72567bc82560c0d/src/traits.rs#L14-L23>
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PartyState {
    #[prost(uint32, tag = "1")]
    pub key_id: u32,
    /// The party's private polynomial
    #[prost(message, optional, tag = "2")]
    pub polynomial: ::core::option::Option<Polynomial>,
    /// The key IDS and associate private keys for this party
    #[prost(message, repeated, tag = "3")]
    pub private_keys: ::prost::alloc::vec::Vec<PrivateKeyShare>,
    /// The nonce being used by this party
    #[prost(message, optional, tag = "4")]
    pub nonce: ::core::option::Option<PrivateNonce>,
}
/// A polynomial.
/// <https://github.com/Trust-Machines/wsts/blob/91a37c8a097e6fa5d5a67519a72567bc82560c0d/src/traits.rs#L14-L23>
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Polynomial {
    /// The coefficients of a polynomial.
    #[prost(message, repeated, tag = "1")]
    pub data: ::prost::alloc::vec::Vec<super::Scalar>,
}
/// The private key share received from another signer
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrivateKeyShare {
    /// The identifier for the private key share. It is unique across all keys
    /// in a DKG round.
    #[prost(uint32, tag = "1")]
    pub key_id: u32,
    /// The private key share.
    #[prost(message, optional, tag = "2")]
    pub private_key: ::core::option::Option<super::Scalar>,
}
/// A nonce
/// <https://github.com/Trust-Machines/wsts/blob/10760178d88c779d9377641e360656b27c05a771/src/common.rs#L51-L58>
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrivateNonce {
    /// A nonce's first value
    #[prost(message, optional, tag = "1")]
    pub nonce_d: ::core::option::Option<super::Scalar>,
    /// A nonce's second value
    #[prost(message, optional, tag = "2")]
    pub nonce_e: ::core::option::Option<super::Scalar>,
}
/// DKG begin message from coordinator to signers
/// This maps to this type <<https://github.com/Trust-Machines/wsts/blob/2d6cb87218bb8dd9ed0519356afe57a0b9a697cb/src/net.rs#L123-L128>>
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DkgBegin {
    /// DKG round ID
    #[prost(uint64, tag = "1")]
    pub dkg_id: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DkgPublicShares {
    #[prost(btree_map = "uint32, message", tag = "1")]
    pub shares: ::prost::alloc::collections::BTreeMap<u32, SignerDkgPublicShares>,
}
/// DKG public shares message from a signer to all signers and coordinator
/// This maps to this type <<https://github.com/Trust-Machines/wsts/blob/2d6cb87218bb8dd9ed0519356afe57a0b9a697cb/src/net.rs#L137-L146>>
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignerDkgPublicShares {
    /// DKG round ID
    #[prost(uint64, tag = "1")]
    pub dkg_id: u64,
    /// Signer ID
    #[prost(uint32, tag = "2")]
    pub signer_id: u32,
    /// List of (signer_id, commitment)
    #[prost(message, repeated, tag = "3")]
    pub commitments: ::prost::alloc::vec::Vec<PartyCommitment>,
}
/// The public polynomial committed to by one of the party members who are
/// participating in distributed key generation.
/// This maps to this type <<https://github.com/Trust-Machines/wsts/blob/2d6cb87218bb8dd9ed0519356afe57a0b9a697cb/src/net.rs#L144-L145>>
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PartyCommitment {
    /// The specific party that submitted the public polynomial.
    #[prost(uint32, tag = "1")]
    pub signer_id: u32,
    /// The public polynomial of the associated party. Each polynomial
    /// includes a proof of ownership of the underlying private private
    /// polynomial.
    #[prost(message, optional, tag = "2")]
    pub commitment: ::core::option::Option<PolyCommitment>,
}
/// DKG private begin message from signer to all signers and coordinator
/// This maps to this type <<https://github.com/Trust-Machines/wsts/blob/2d6cb87218bb8dd9ed0519356afe57a0b9a697cb/src/net.rs#L162-L171>>
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DkgPrivateBegin {
    /// DKG round ID
    #[prost(uint64, tag = "1")]
    pub dkg_id: u64,
    /// Signer IDs who responded in time for this DKG round
    #[prost(uint32, repeated, tag = "2")]
    pub signer_ids: ::prost::alloc::vec::Vec<u32>,
    /// Key IDs who responded in time for this DKG round
    #[prost(uint32, repeated, tag = "3")]
    pub key_ids: ::prost::alloc::vec::Vec<u32>,
}
/// DKG private shares message from signer to all signers and coordinator
/// This maps to this type <<https://github.com/Trust-Machines/wsts/blob/2d6cb87218bb8dd9ed0519356afe57a0b9a697cb/src/net.rs#L185-L195>>
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DkgPrivateShares {
    /// DKG round ID
    #[prost(uint64, tag = "1")]
    pub dkg_id: u64,
    /// Signer ID
    #[prost(uint32, tag = "2")]
    pub signer_id: u32,
    /// List of (src_signer_id, Map(dst_key_id, encrypted_share))
    #[prost(message, repeated, tag = "3")]
    pub shares: ::prost::alloc::vec::Vec<PrivateShare>,
}
/// This was created
/// This maps to this type <<https://github.com/Trust-Machines/wsts/blob/2d6cb87218bb8dd9ed0519356afe57a0b9a697cb/src/net.rs#L193-L194>>
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrivateShare {
    /// The ID of the signer that created the secret share.
    #[prost(uint32, tag = "1")]
    pub source_signer_id: u32,
    /// The encrypted private shares to send to another parties.
    #[prost(message, repeated, tag = "2")]
    pub encrypted_shares: ::prost::alloc::vec::Vec<SecretShare>,
}
/// This maps to this type <<https://github.com/Trust-Machines/wsts/blob/2d6cb87218bb8dd9ed0519356afe57a0b9a697cb/src/net.rs#L193-L194>>
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecretShare {
    /// The signer ID associated with the secret share. This is the only
    /// signer who will be able to decrypt the encrypted_secret_share field.
    #[prost(uint32, tag = "1")]
    pub signer_id: u32,
    /// This is the private polynomial evaluated at the `signer_id` and then
    /// encrypted in such a way that only the public key associated with the
    /// above `signer_id` can decrypt it.
    #[prost(bytes = "vec", tag = "2")]
    pub encrypted_secret_share: ::prost::alloc::vec::Vec<u8>,
}
/// DKG end begin message from signer to all signers and coordinator
/// This maps to this type <<https://github.com/Trust-Machines/wsts/blob/2d6cb87218bb8dd9ed0519356afe57a0b9a697cb/src/net.rs#L222-L231>>
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DkgEndBegin {
    /// DKG round ID
    #[prost(uint64, tag = "1")]
    pub dkg_id: u64,
    /// Signer IDs who responded in time for this DKG round
    #[prost(uint32, repeated, tag = "2")]
    pub signer_ids: ::prost::alloc::vec::Vec<u32>,
    /// Key IDs who responded in time for this DKG round
    #[prost(uint32, repeated, tag = "3")]
    pub key_ids: ::prost::alloc::vec::Vec<u32>,
}
/// DKG end message from signers to coordinator
/// This maps to this type <<https://github.com/Trust-Machines/wsts/blob/2d6cb87218bb8dd9ed0519356afe57a0b9a697cb/src/net.rs#L246-L255>>
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DkgEnd {
    /// DKG round ID
    #[prost(uint64, tag = "1")]
    pub dkg_id: u64,
    /// Signer ID
    #[prost(uint32, tag = "2")]
    pub signer_id: u32,
    /// DKG status for this Signer after receiving public/private shares
    #[prost(message, optional, tag = "3")]
    pub status: ::core::option::Option<DkgStatus>,
}
/// Signature type
/// This maps to this type <<https://github.com/Trust-Machines/wsts/blob/ebd7d7775ad5e44cdbf4f5c1fb468bdf6c467265/src/net.rs#L373-L382>>
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignatureType {
    #[prost(oneof = "signature_type::SignatureType", tags = "1, 2, 3")]
    pub signature_type: ::core::option::Option<signature_type::SignatureType>,
}
/// Nested message and enum types in `SignatureType`.
pub mod signature_type {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SignatureType {
        /// FROST signature
        #[prost(message, tag = "1")]
        Frost(super::FrostSignatureType),
        /// BIP-340 Schnorr proof
        #[prost(message, tag = "2")]
        Schnorr(super::SchnorrSignatureType),
        /// BIP-341 Taproot style schnorr proof with a merkle root
        #[prost(message, tag = "3")]
        Taproot(super::TaprootSignatureType),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FrostSignatureType {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SchnorrSignatureType {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaprootSignatureType {
    /// Taproot merkle root. This field is optional
    #[prost(message, optional, tag = "1")]
    pub merkle_root: ::core::option::Option<MerkleRoot>,
}
/// Nonce request message from coordinator to signers
/// This maps to this type <<https://github.com/Trust-Machines/wsts/blob/2d6cb87218bb8dd9ed0519356afe57a0b9a697cb/src/net.rs#L265-L280>>
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NonceRequest {
    /// DKG round ID
    #[prost(uint64, tag = "1")]
    pub dkg_id: u64,
    /// Signing round ID
    #[prost(uint64, tag = "2")]
    pub sign_id: u64,
    /// Signing round iteration ID
    #[prost(uint64, tag = "3")]
    pub sign_iter_id: u64,
    /// The message to sign
    #[prost(bytes = "vec", tag = "4")]
    pub message: ::prost::alloc::vec::Vec<u8>,
    /// What type of signature to create
    #[prost(message, optional, tag = "5")]
    pub signature_type: ::core::option::Option<SignatureType>,
}
/// Nonce response message from signers to coordinator
/// This maps to this type <<https://github.com/Trust-Machines/wsts/blob/2d6cb87218bb8dd9ed0519356afe57a0b9a697cb/src/net.rs#L309-L326>>
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NonceResponse {
    /// DKG round ID
    #[prost(uint64, tag = "1")]
    pub dkg_id: u64,
    /// Signing round ID
    #[prost(uint64, tag = "2")]
    pub sign_id: u64,
    /// Signing round iteration ID
    #[prost(uint64, tag = "3")]
    pub sign_iter_id: u64,
    /// Signer ID
    #[prost(uint32, tag = "4")]
    pub signer_id: u32,
    /// Key IDs
    #[prost(uint32, repeated, tag = "5")]
    pub key_ids: ::prost::alloc::vec::Vec<u32>,
    /// Public nonces
    #[prost(message, repeated, tag = "6")]
    pub nonces: ::prost::alloc::vec::Vec<PublicNonce>,
    /// Bytes being signed.
    #[prost(bytes = "vec", tag = "7")]
    pub message: ::prost::alloc::vec::Vec<u8>,
}
/// Signature share request message from coordinator to signers
/// This maps to this type <<https://github.com/Trust-Machines/wsts/blob/2d6cb87218bb8dd9ed0519356afe57a0b9a697cb/src/net.rs#L370-L387>>
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignatureShareRequest {
    /// DKG round ID
    #[prost(uint64, tag = "1")]
    pub dkg_id: u64,
    /// Signing round ID
    #[prost(uint64, tag = "2")]
    pub sign_id: u64,
    /// Signing round iteration ID
    #[prost(uint64, tag = "3")]
    pub sign_iter_id: u64,
    /// Nonces responses used for this signature
    #[prost(message, repeated, tag = "4")]
    pub nonce_responses: ::prost::alloc::vec::Vec<NonceResponse>,
    /// Bytes to sign.
    #[prost(bytes = "vec", tag = "5")]
    pub message: ::prost::alloc::vec::Vec<u8>,
    /// What type of signature to create
    #[prost(message, optional, tag = "6")]
    pub signature_type: ::core::option::Option<SignatureType>,
}
/// Signature share response message from signers to coordinator
/// This maps to this type <<https://github.com/Trust-Machines/wsts/blob/2d6cb87218bb8dd9ed0519356afe57a0b9a697cb/src/net.rs#L422-L435>>
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignatureShareResponse {
    /// DKG round ID
    #[prost(uint64, tag = "1")]
    pub dkg_id: u64,
    /// Signing round ID
    #[prost(uint64, tag = "2")]
    pub sign_id: u64,
    /// Signing round iteration ID
    #[prost(uint64, tag = "3")]
    pub sign_iter_id: u64,
    /// Signer ID
    #[prost(uint32, tag = "4")]
    pub signer_id: u32,
    /// Signature shares from this Signer
    #[prost(message, repeated, tag = "5")]
    pub signature_shares: ::prost::alloc::vec::Vec<SignatureShare>,
}
/// A commitment to a polynomial, with a Schnorr proof of ownership bound to the ID
/// This maps to this type <<https://github.com/Trust-Machines/wsts/blob/10760178d88c779d9377641e360656b27c05a771/src/common.rs#L25-L32>>
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolyCommitment {
    /// The party ID with a Schnorr proof
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<ProofIdentifier>,
    /// The public polynomial which commits to the secret polynomial
    #[prost(message, repeated, tag = "2")]
    pub poly: ::prost::alloc::vec::Vec<super::Point>,
}
/// This type maps to the `ID` type in WSTS, which encapsulates the ID and a
/// Schnorr proof of ownership of the polynomial.
/// This maps to this type <<https://github.com/Trust-Machines/wsts/blob/7435dec216aab547133de0dc2915e49875630c84/src/schnorr.rs#L12-L23>>
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProofIdentifier {
    /// The ID
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<super::Scalar>,
    /// The public Schnorr response, kG
    #[prost(message, optional, tag = "2")]
    pub schnorr_response: ::core::option::Option<super::Point>,
    /// The aggregate of the Schnorr committed values, kca
    #[prost(message, optional, tag = "3")]
    pub aggregate_commitment: ::core::option::Option<super::Scalar>,
}
/// Final DKG status after receiving public and private shares
/// This maps to this type <<https://github.com/Trust-Machines/wsts/blob/2d6cb87218bb8dd9ed0519356afe57a0b9a697cb/src/net.rs#L72-L79>>
/// combined with this type <<https://github.com/Trust-Machines/wsts/blob/2d6cb87218bb8dd9ed0519356afe57a0b9a697cb/src/net.rs#L57-L70>>
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DkgStatus {
    #[prost(oneof = "dkg_status::Mode", tags = "1, 2, 3, 4, 5, 6, 7")]
    pub mode: ::core::option::Option<dkg_status::Mode>,
}
/// Nested message and enum types in `DkgStatus`.
pub mod dkg_status {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Mode {
        /// DKG completed successfully
        #[prost(message, tag = "1")]
        Success(super::Success),
        /// Signer was in the wrong internal state to complete DKG
        #[prost(message, tag = "2")]
        BadState(super::BadState),
        /// DKG public shares were missing from these signer_ids
        #[prost(message, tag = "3")]
        MissingPublicShares(super::MissingPublicShares),
        /// DKG public shares were bad from these signer_ids
        #[prost(message, tag = "4")]
        BadPublicShares(super::BadPublicShares),
        /// DKG private shares were missing from these signer_ids
        #[prost(message, tag = "5")]
        MissingPrivateShares(super::MissingPrivateShares),
        /// DKG private shares were bad from these signer_ids
        #[prost(message, tag = "6")]
        BadPrivateShares(super::BadPrivateShares),
        /// The DKG threshold was not met
        #[prost(message, tag = "7")]
        Threshold(super::Threshold),
    }
}
/// DKG completed successfully
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Success {}
/// Signer was in the wrong internal state to complete DKG
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BadState {}
/// DKG public shares were bad from these signer_ids.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MissingPublicShares {
    /// In WSTS this is a HashSet<u32>, so these should be unique, duplicates
    /// will be ignored at the application level.
    #[prost(btree_map = "uint32, message", tag = "1")]
    pub signer_ids: ::prost::alloc::collections::BTreeMap<u32, super::SetValueZst>,
}
/// DKG public shares were bad from these signer_ids.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BadPublicShares {
    /// In WSTS this is a HashSet<u32>, so these should be unique, duplicates
    /// will be ignored at the application level.
    #[prost(btree_map = "uint32, message", tag = "1")]
    pub signer_ids: ::prost::alloc::collections::BTreeMap<u32, super::SetValueZst>,
}
/// DKG private shares were missing from these signer_ids.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MissingPrivateShares {
    /// In WSTS this is a HashSet<u32>, so these should be unique, duplicates
    /// will be ignored at the application level.
    #[prost(btree_map = "uint32, message", tag = "1")]
    pub signer_ids: ::prost::alloc::collections::BTreeMap<u32, super::SetValueZst>,
}
/// DKG private shares were bad from these signer_ids.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BadPrivateShares {
    #[prost(btree_map = "uint32, message", tag = "1")]
    pub shares: ::prost::alloc::collections::BTreeMap<u32, BadPrivateShare>,
}
/// A bad private share
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BadPrivateShare {
    /// The DH shared key between these participants
    #[prost(message, optional, tag = "1")]
    pub shared_key: ::core::option::Option<super::Point>,
    /// Proof that the shared key is a valid DH tuple as per Chaum-Pedersen.
    #[prost(message, optional, tag = "2")]
    pub tuple_proof: ::core::option::Option<TupleProof>,
}
/// A Chaum-Pedersen proof that (G, A=a*G, B=b*G, K=(a*b)*G) is a
/// Diffie-Hellman tuple.
/// This maps to this type <<https://github.com/Trust-Machines/wsts/blob/10760178d88c779d9377641e360656b27c05a771/src/common.rs#L163-L172>>
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TupleProof {
    /// This is a commitment to both the random commitment in the Schnorr
    /// proof and the private key used for the signature. It represents r*B.
    #[prost(message, optional, tag = "1")]
    pub combined_commitment: ::core::option::Option<super::Point>,
    /// The Schnorr proof using the commitment of the above Point.
    #[prost(message, optional, tag = "2")]
    pub signature: ::core::option::Option<SchnorrProof>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SchnorrProof {
    /// This is R, where R = r*G for a random scalar r.
    #[prost(message, optional, tag = "1")]
    pub random_commitment: ::core::option::Option<super::Point>,
    /// This is z, where z = r + a*s where s = H(G,A,B,K,R) as per Fiat-Shamir
    #[prost(message, optional, tag = "2")]
    pub response: ::core::option::Option<super::Scalar>,
}
/// A merkle root is a 256 bit hash
/// This maps to this type <<https://github.com/Trust-Machines/wsts/blob/10760178d88c779d9377641e360656b27c05a771/src/common.rs#L22-L23>>
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MerkleRoot {
    /// The root of the merkle tree
    #[prost(message, optional, tag = "1")]
    pub root: ::core::option::Option<super::Uint256>,
}
/// A commitment to the private nonce
/// This maps to this type <<https://github.com/Trust-Machines/wsts/blob/10760178d88c779d9377641e360656b27c05a771/src/common.rs#L94-L102>>
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublicNonce {
    /// A commitment to the private nonce's first value
    #[prost(message, optional, tag = "1")]
    pub nonce_d: ::core::option::Option<super::Point>,
    /// A commitment to the private nonce's second value
    #[prost(message, optional, tag = "2")]
    pub nonce_e: ::core::option::Option<super::Point>,
}
/// A share of the party signature with related values
/// This maps to this type <<https://github.com/Trust-Machines/wsts/blob/10760178d88c779d9377641e360656b27c05a771/src/common.rs#L120-L129>>
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignatureShare {
    /// The ID of the party
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// The party signature, z_i
    #[prost(message, optional, tag = "2")]
    pub signature_share: ::core::option::Option<super::Scalar>,
    /// The key IDs of the party
    #[prost(uint32, repeated, tag = "3")]
    pub key_ids: ::prost::alloc::vec::Vec<u32>,
}
/// The DKG threshold has not been upheld by the coordinator.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Threshold {}
